# Tree Traversal Algorithm
### Iteratively finding summation of root-to-leaf paths

##### Mathematical Formula:Given employee’s e<sub>1</sub>, e<sub>2</sub>, …, e<sub>n</sub> where an employee e<sub>i</sub> has value v and pid p where v is a positive integer and p is a positive integer less than i. We define a parent as e<sub>p</sub> for any e<sub>i</sub>, and an ancestor as any employee which can be found by recursively e<sub>p</sub> until we reach e<sub>1</sub>. We are also given positive integer k. Find the largest possible value by selecting k employees and summing the v for those employees and all their ancestors, not counting any v more than once.##### English Description:After we parse the input file into an array of Employees, we iterate through the array and create an array of which indices are leaves by adding every index to the list and then removing it if is listed as a parent id. We then iterate through the array of Employees and calculate the potential value of influencing each employee by adding an employee’s individual value to its parent’s potential value. While we can still select more employees to influence we find the index from the array of leaves with the highest potential value and influence that employee. We add its potential value to the final integer to be returned and set the value of each employee influence to 0. We find the “sub-tree” of the last employee to be influenced that is not the CEO and recalculate the potential value for all of its children. When we cannot select more employees to influence we return the summation of the influences.#### Pseudo Code:Read first line from stdin, first integer in line is n, second integer in line is k<br>Create array of employees of size n<br>While there are lines in stdin {<br>Create employee where the pid is the second integer in the line and the initial<br> value is the third integer in the line, potential value is 0<br>	Add employee to next spot in the array of employees<br>}<br>Create array of arraylists to keep track of children<br>Create array of Booleans to denote which indices are leaves<br>For integer i, equals zero, is less than n, increment i {<br>	Set index i in array of leaves to true<br>	Set index i in array of children to empty ArrayList<br>	Get pid of index i in array of employees<br>	Set index pid in array of leaves to false<br>	Add i to index pid in array of children<br>	Set the potential value of the employee at the corresponding index to the sum of its initial value and its parents potential value<br>}<br>Create array of integers to denote indices of leaves<br>Iterate through array of Booleans for leaves {<br>	If current index is true, add current index to array of leaves<br>}<br>While k is not 0 (i.e. there are more employees we can influence) {<br>	Iterate through list of leaf indices {<br>If the employee denoted by the current index has a higher potential value than any of the previous ones, save it and the index<br>	}<br>Add the highest potential value of the leaves to the final utility value to be returned<br>Recur through the leaf we selected and its parents setting all their initial and potential values to 0. Then recur through that employees children and recalculate its potential value<br>Decrement k<br>}<br>Write final utility value to stdout#### Proof of Correctness:The algorithm is capable of running in efficient time by taking advantage of the fact that an employee will never have a negative utility value. When we couple this knowledge with the fact that any influenced employee will proceed to influence his boss and this continues until the CEO is reached, we can discern that it is always advantageous to influence an employee which is not a parent to any other employees. Mathematically, given employee e<sub>n</sub> which produces a total value k by influencing, including parents, if e<sub>n</sub> has any children, any child e<sub>c</sub> will have total value k + w by influencing, including parents, since w is not negative we know k + w >= k, i.e. the value of e<sub>c</sub> >= the value of e<sub>n</sub> for any employee. Thus we have established, optimally, whenever we influence an employee that employee must be a “leaf” in a tree analogy, in other words there must be no other employee which identifies that employee as a parent.#### Run Time Analysis:We calculate worst case scenario for running this algorithm. n is the number of employees given to be processed, k is the number of employees we are allowed to influence directly. We analyze the pseudo code run time to find total run time.Reading in list of employees: Entirely dependent on size of list O(n)Initializing arrays of leaves, children, employees, all size n: Entirely dependent on size of list O(n)Adding up potential value of employees: Worst case we have to recalculate potential value of all employees O(n)Influencing k employees: Must iterate through list of leaves, worst case we have to search through list of size n – 1, k times O(nk)Setting the values of all used employees to 0: Worst case is all employees used at once O(n)Worst case scenario thus involves O(n) + O(n) + O(n) + O(n) + O(nk) = O(nk + 4n) which equates to O(nk) in big O notation.